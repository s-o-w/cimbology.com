<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case Study: Cimbology - Shawn Weekly</title>
    <meta name="description" content="How I built Cimbology, a GraphRAG system for electrical utility engineers, proving AI can be both accurate and trustworthy.">
    <meta property="og:title" content="Case Study: Cimbology - Shawn Weekly">
    <meta property="og:description" content="A deep research project proving how GraphRAG can solve the retiring expert problem in the electrical utility industry">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/case-study.css">
</head>
<body>
<header style="background-color: var(--primary-color);">
    <div class="logo-container">
        <button class="mobile-menu-toggle" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <nav class="main-nav">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="cimbology-case-study.html">Case Study: Cimbology</a></li>
                <li><a href="dotTC57.html">dotTC57 Library</a></li>
                <li><a href="ai-philosophy.html">My AI Philosophy</a></li>
                <li><a href="ideal-role.html">My Ideal Role</a></li>
                <li><a href="why-cim-matters.html">Why CIM Matters</a></li>
                <li><a href="index.html#contact">Contact</a></li>
            </ul>
        </nav>
        <img src="imgs/CimbologyLogo_transparent.png" alt="Cimbology Logo" class="main-logo">
        <h1>Case Study: Cimbology</h1>
        <h2>An AI Knowledge Assistant for Utility Engineers</h2>
        <p class="tagline">By Shawn Weekly | Deep Research Project | 2024-2025</p>

        <!-- Quick Navigation -->
        <nav class="quick-nav">
            <button class="quick-nav-toggle" aria-label="Toggle quick navigation">
                <span>Page Sections</span>
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path
                        d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z" />
                </svg>
            </button>
            <div class="quick-nav-items">
                <a href="#executive-summary" class="quick-nav-btn">Executive Summary</a>
                <a href="#business-problem" class="quick-nav-btn">Business Problem</a>
                <a href="#architecture" class="quick-nav-btn">Architecture</a>
                <a href="#research" class="quick-nav-btn">Research</a>
                <a href="#tech-stack" class="quick-nav-btn">Tech Stack</a>
                <a href="#proof-of-work" class="quick-nav-btn">Proof of Work</a>
                <a href="#lessons-learned" class="quick-nav-btn">What I Learned</a>
                <a href="#cta" class="quick-nav-btn">Contact</a>
            </div>
        </nav>
    </div>
</header>
    
    <div class="scrollable-content">
    <!-- Partially Generated by Copilot -->
    <section id="executive-summary" class="executive-summary">
        <div class="container">
            <h2>Executive Summary</h2>
            
            <div class="summary-grid">
                <div class="summary-card">
                    <h3>The Problem</h3>
                    <p>
                        The electrical utility industry loses decades of irreplaceable expertise every 
                        time a senior engineer retires. How do you capture and make accessible 30+ years 
                        of tacit knowledge, specifications, and domain understanding?
                    </p>
                </div>
                
                <div class="summary-card">
                    <h3>The Hypothesis</h3>
                    <p>
                        Can combining Knowledge Graphs with RAG (Retrieval-Augmented Generation)
                        across unstructured, information rich documentation ( called GraphRAG) create a 
                        verifiable, <strong>trustworthy</strong> AI assistant for engineering decisions?
                    </p>
                </div>
                
                <div class="summary-card">
                    <h3>The Proof</h3>
                    <p>
                        I built a full-stack GraphRAG system and tested it against a real Professional 
                        Engineering (PE) exam. Results: <strong>84.85% accuracy with full citation 
                        traceability</strong> vs. 77% for baseline LLM with zero traceability.
                    </p>
                </div>
            </div>
            
            <div class="key-insight">
                <h3>Key Insight</h3>
                <blockquote>
                    "A baseline LLM behaves like a 'dumb-but-fast' intern who has read every book 
                    but understood nothing. Add structured knowledge via a Knowledge Graph and you 
                    get an assistant that can reason, cite sources, and be trusted."
                </blockquote>
            </div>
        </div>
    </section>
    
    <section id="business-problem" class="business-problem">
        <div class="container">
            <h2>The Business Problem: The "Jack and Susan" Scenario</h2>
            
            <div class="story-intro">
                <p>Meet Jack and Susan, two pillars of expertise at their electrical engineering firm.</p>
            </div>

            <div id="jack">
                <div class="character">
                    <h4 class="fw-bold">Jack</h4>
                    <div class="character-details">
                        <p class="fw-normal">A master substation physical designer with over 30 years of experience.</p>
                        <p class="fw-normal">Jack creates the physical layouts and ensures that substations are properly designed for construction and maintenance.</p>
                        <p class="fw-normal">With exceptional skills in AutoCAD and Autodesk Inventor, he's the go-to expert that colleagues rely on daily.</p>
                    </div>
                </div>
            </div>

            <div id="susan">
                <div class="character">
                    <h4 class="fw-bold">Susan</h4>
                    <div class="character-details">
                        <p class="fw-normal">An electrical engineer with 30+ years designing protection and control schemes for the substations her company designs and builds.</p>
                        <p class="fw-normal">Susan knows AutoCAD Electrical like the back of her hand.</p>
                        <p class="fw-normal">She always knows exactly where to find the right standards, specifications, and information needed for any project.</p>
                    </div>
                </div>
            </div>

            <div id="problem">
                <h3>The Challenge</h3>
                <p>Jack and Susan are retiring next month. Although they've shared all their specifications, drawings, files, and documents with their team, it's an overwhelming amount of information.</p>
                <p class="question">How will the team digest this wealth of knowledge?</p>
                <p class="question">How can they find what they need when they need it?</p>
            </div>
            
            <div class="problem-statement">
                <h3>Why This Matters</h3>
                <p>
                    This scenario plays out across the electrical utility industry every day. 
                    Organizations lose not just employees, but decades of hard-won knowledge about:
                </p>
                <ul>
                    <li>Design standards and best practices specific to their region/utility</li>
                    <li>Tacit knowledge about "why" certain decisions were made historically</li>
                    <li>Tribal knowledge about reliable vendors, proven solutions, and lessons learned</li>
                    <li>The location and meaning of thousands of specifications, drawings, and documents</li>
                </ul>
                <p>
                    Traditional knowledge & document management systems (SharePoint, Autodesk Vault, ProjectWise, file servers) 
                    preserve the <em>documents</em> but not the <em>expertise</em> to navigate and apply them 
                    effectively. And many of the systems above are often improperly configured and don't (or simply can't) 
                    deliver good search results.
                </p>
            </div>
        </div>
    </section>
    
    <section id="architecture" class="architectural-solution">
        <div class="container">
            <h2>The Architectural Solution: GraphRAG</h2>
            
            <div class="architecture-intro">
                <p>
                    I architected Cimbology to test whether a hybrid approach that combined the structured 
                    reasoning of Knowledge Graphs, the proven capabilities of RAG based search, and the flexibility of 
                    Large Language Models could solve the "verifiable expertise" problem.
                </p>
            </div>
            
            <div class="diagram-placeholder">
                <div class="architecture-diagram">
                    <h3>System Architecture</h3>
                    <div class="mermaid">
                        graph TB
                        User[User/Engineer] -->|Query| WebUI[Web Interface<br />HTML/AlpineJS]
                        User -->|Query| AutoCAD[AutoCAD Plugin<br />WPF/.NET]
                
                        WebUI --> API[API Gateway<br />ASP.NET Core / .NET 9]
                        AutoCAD --> API
                
                        API --> QS[Query Service<br />Semantic Kernel Orchestration]
                
                        QS --> KG[Knowledge Graph Query<br />SPARQL Service]
                        QS --> VS[Vector Search<br />RAG Service]
                
                        KG --> GraphDB[(GraphDB<br />RDF Triplestore<br />CIM Ontology)]
                        VS --> Qdrant[(Qdrant<br />Vector Database<br />Document Embeddings)]
                
                        QS --> LLM[LLM Provider<br />Azure OpenAI / Google Gemini]
                
                        LLM --> Response[AI Response with<br />Citations & Traceability]
                        Response --> API
                        API --> WebUI
                        API --> AutoCAD
                
                        API --> SQLite[(SQLite<br />Session Storage)]
                
                        style User fill:#e1f5ff
                        style Response fill:#d4edda
                        style GraphDB fill:#fff3cd
                        style Qdrant fill:#fff3cd
                        style SQLite fill:#fff3cd
                        style LLM fill:#f8d7da
                        style QS fill:#d1ecf1
                    </div>
                </div>
            </div>
            
            <div class="architecture-components">
                <h3>Core Components</h3>
                
                <div class="component-card">
                    <h4>Knowledge Graph (RDF Triplestore)</h4>
                    <p>
                        Uses <strong>GraphDB</strong> and <strong>SPARQL</strong> to store structured 
                        domain knowledge based on the IEC 61970/61968 CIM standard. This provides the 
                        "reasoning backbone"; the means for the system to understand the relationships 
                        between Substations, ConductingEquipment, Measurements, etc.
                    </p>
                    <p><strong>Why it matters:</strong> Structured knowledge is verifiable and can be 
                    reasoned over. RADICAL reduction in hallucinations.</p>
                </div>
                
                <div class="component-card">
                    <h4>Vector Database (Qdrant)</h4>
                    <p>
                        Stores embeddings of document chunks (PDF pages, sections, tables) enabling 
                        semantic search over unstructured content. Uses advanced chunking strategies 
                        (layout-aware, table extraction, multimodal image descriptions) to preserve context.
                    </p>
                    <p><strong>Why it matters:</strong> Unstructured documents contain the bulk of 
                    engineering knowledge. RAG makes them searchable and retrievable. Advanced chunking gets 
                    ALL of the information from the documents, not just the text in the paragraphs.</p>
                </div>
                
                <div class="component-card">
                    <h4>AI Orchestration (Semantic Kernel)</h4>
                    <p>
                        Coordinates queries across both the Knowledge Graph and Vector Database, then 
                        synthesizes results using an LLM (Google Gemini or Azure OpenAI). Provides 
                        prompt engineering, context management, and citation tracking.
                    </p>
                    <p><strong>Why it matters:</strong> The orchestrator ensures the LLM receives 
                    high-quality, verifiable contextâ€”not just "best guess" vectors.</p>
                </div>
                
                <div class="component-card">
                    <h4>Backend API (.NET 9)</h4>
                    <p>
                        RESTful API built with ASP.NET Core, Entity Framework Core, and dotnetRDF. 
                        Handles chat sessions, query routing, session persistence (SQLite), and 
                        multi-modal client support (web, AutoCAD plugin).
                    </p>
                    <p><strong>Why it matters:</strong> Enterprise-grade reliability, testability, 
                    and maintainability.</p>
                </div>
            </div>
            
            <div class="design-decisions">
                <h3>Key Design Decisions</h3>
                <ul>
                    <li>
                        <strong>Why .NET 9?</strong> Enterprise-ready, high-performance, excellent 
                        tooling. Strong typing reduces bugs in complex domain logic. DotNet is one of the primary
                        technology stacks used in the utility industry due to the universal use of Windows as the primary OS.
                    </li>
                    <li>
                        <strong>Why Semantic Kernel?</strong> AI orchestration without vendor lock-in. 
                        Supports multiple LLM providers (Azure OpenAI, Google AI, local models). Written in dotnet.
                    </li>
                    <li>
                        <strong>Why dotnetRDF?</strong> The CIM standard is RDF-native. Using dotnetRDF 
                        means working with the domain model in its natural form (OWL/RDFS).
                    </li>
                    <li>
                        <strong>Why GraphDB + Qdrant (hybrid storage)?</strong> Different data needs 
                        different stores. Structured = Graph. Unstructured = Vectors. Best of both worlds.
                    </li>
                    <li>
                        <strong>Why Docker?</strong> Reproducible dev environment. Easy deployment. 
                        Supports local development and cloud deployment without code changes.
                    </li>
                </ul>
            </div>
        </div>
    </section>
    
    <section id="research" class="research-methodology">
        <div class="container">
            <h2>Research Methodology & Results</h2>
            
            <div class="methodology-intro">
                <p>
                    To prove the effectiveness of GraphRAG, I needed a real-world test. I purchased and used a 
                    Professional Engineering (PE) exam from 2025 and tested four different approaches 
                    against a corpus of 2017-era engineering standards documents.
                </p>
                <p>
                    <strong>The Challenge:</strong> If the system can answer 2025 exam questions 
                    using outdated 2017 documents, it proves the system truly understands context 
                    and relationships; it's not just keyword matching.
                </p>
            </div>
            
            <div class="test-approaches">
                <h3>Four Approaches Tested</h3>
                
                <div class="approach-grid">
                    <div class="approach-card">
                        <h4>1. Baseline LLM (No RAG)</h4>
                        <p class="score">77.27% Accuracy</p>
                        <p>
                            Sent questions directly to GPT-5-Mini on Azure OpenAI with zero context. Fast and 
                            surprisingly accurate, but completely unverifiable. A "black box."
                        </p>
                        <p class="verdict"><strong>Verdict:</strong> Untrustworthy for engineering decisions</p>
                    </div>
                    
                    <div class="approach-card">
                        <h4>2. Simple RAG</h4>
                        <p class="score">53.03% Accuracy</p>
                        <p>
                            Used basic page-level embeddings and naive vector search against Google Gemini 2.5 Pro. Performed 
                            worse than baseline! Proved that "adding RAG" doesn't automatically improve results.
                        </p>
                        <p class="verdict"><strong>Verdict:</strong> Naive RAG is actively harmful</p>
                    </div>
                    
                    <div class="approach-card">
                        <h4>3. Advanced RAG</h4>
                        <p class="score">83.33% Accuracy</p>
                        <p>
                            Used layout-aware chunking, table extraction, and multimodal image 
                            descriptions and went back to Azure OpenAI and GPT-5-Mini. Major improvement, proves context quality 
                            matters more than model size.
                        </p>
                        <p class="verdict"><strong>Verdict:</strong> Much better, but still missing structured, semantic reasoning</p>
                    </div>
                    
                    <div class="approach-card highlight">
                        <h4>4. KG-Enhanced RAG (GraphRAG) along with the context from Step 3 above.</h4>
                        <p class="score">84.85% Accuracy</p>
                        <p>
                            Combined Advanced RAG with Knowledge Graph reasoning. Achieved highest 
                            accuracy <strong>and</strong> provided full citation traceability.
                        </p>
                        <p class="verdict"><strong>Verdict:</strong> Winner. Accurate and trustworthy.</p>
                    </div>
                </div>
            </div>
            
            <div class="key-findings">
                <h3>Key Findings</h3>
                <ul>
                    <li>
                        <strong>Context Quality > Model Size:</strong> Advanced chunking strategies 
                        improved accuracy by 30%+ over naive RAG.
                    </li>
                    <li>
                        <strong>Structure Matters:</strong> The Knowledge Graph added the final 7% 
                        accuracy boost, but more importantly, enabled citation and reasoning transparency.
                    </li>
                    <li>
                        <strong>Naive RAG is Dangerous:</strong> Simple RAG performed 24% worse than 
                        no RAG at all. That's a critical lesson for anyone implementing AI systems.
                    </li>
                    <li>
                        <strong>Traceability is Non-Negotiable:</strong> In engineering, you can't 
                        use an answer you can't verify. GraphRAG provides both accuracy and trust.
                    </li>
                </ul>
            </div>
            
            <div class="methodology-details">
                <p class="small-text">
                    <strong>Full Methodology:</strong> Tested against 66 PE exam questions. Documents 
                    included IEEE standards, NESC code, and utility design guides (all from 2017 or earlier). 
                    Used Google Gemini AND Azure OpenAI to ensure comparison across different vendor models. 
                    Accuracy measured by correct answer selection (A/B/C/D). See the 
                    <a href="pe_exam_analysis.html">full interactive analysis</a> for question-by-question breakdown.
                </p>
            </div>
        </div>
    </section>
    
    <!-- Section 5: Technology Stack -->
    <section id="tech-stack" class="tech-stack">
        <div class="container">
            <h2>Technology Stack</h2>
            
            <div class="stack-category">
                <h3>Backend & Core Logic</h3>
                <ul>
                    <li><strong>.NET 9</strong> - Enterprise-grade performance and tooling</li>
                    <li><strong>C#</strong> - Strong typing for complex domain logic</li>
                    <li><strong>ASP.NET Core</strong> - RESTful API framework</li>
                    <li><strong>Entity Framework Core</strong> - ORM for session persistence</li>
                </ul>
            </div>
            
            <div class="stack-category">
                <h3>AI & Machine Learning</h3>
                <ul>
                    <li><strong>Microsoft Semantic Kernel</strong> - AI orchestration layer</li>
                    <li><strong>Google Gemini and Azure OpenAI</strong> - LLM providers </li>
                    <li><strong>RAG (Retrieval-Augmented Generation)</strong> - Document-based context retrieval</li>
                    <li><strong>GraphRAG</strong> - Hybrid Knowledge Graph + RAG approach</li>
                </ul>
            </div>
            
            <div class="stack-category">
                <h3>Data Storage & Retrieval</h3>
                <ul>
                    <li><strong>Qdrant</strong> - Vector database for document embeddings</li>
                    <li><strong>Ontotext GraphDB</strong> - RDF triplestore for Knowledge Graph</li>
                    <li><strong>SQLite</strong> - Session and chat history persistence</li>
                    <li><strong>SPARQL</strong> - Query language for Knowledge Graph</li>
                </ul>
            </div>
            
            <div class="stack-category">
                <h3>Standards & Domain Models</h3>
                <ul>
                    <li><strong>IEC 61970/61968 (CIM)</strong> - Common Information Model standard</li>
                    <li><strong>dotTC57</strong> - My open-source .NET library for CIM</li>
                    <li><strong>dotnetRDF</strong> - RDF, OWL, and SPARQL processing library</li>
                    <li><strong>RDF/OWL/SHACL</strong> - Semantic web technologies</li>
                </ul>
            </div>
            
            <div class="stack-category">
                <h3>Client Interfaces</h3>
                <ul>
                    <li><strong>HTML/JavaScript/AlpineJS</strong> - Web-based chat interface</li>
                    <li><strong>AutoCAD (WPF) Plugin</strong> - In-CAD knowledge assistant</li>
                </ul>
            </div>
            
            <div class="stack-category">
                <h3>DevOps & Infrastructure</h3>
                <ul>
                    <li><strong>Docker & Docker Compose</strong> - Containerized deployment</li>
                    <li><strong>Nginx</strong> - Reverse proxy and static file serving</li>
                    <li><strong>Git/GitHub</strong> - Version control and collaboration</li>
                </ul>
            </div>
        </div>
    </section>
    
    <!-- Section 6: Proof of Work -->
    <section id="proof-of-work" class="proof-of-work">
        <div class="container">
            <h2>Proof of Work: The Code</h2>
            
            <div class="pow-intro">
                <p>
                    Unlike many "research projects" that remain theoretical, Cimbology is fully 
                    implemented, tested, and deployed. Every component described above exists as 
                    working code.
                </p>
                <p>
                    <strong>Full source code:</strong> 
                    <a href="https://github.com/s-o-w/CIMbology.ai" target="_blank">github.com/s-o-w/CIMbology.ai</a>
                </p>
            </div>
            
            <div class="code-showcase">
                <h3>Key Components</h3>
                
                <div class="code-card">
                    <h4>Query Service (GraphRAG Orchestration)</h4>
                    <p class="file-link">
                        <a href="https://github.com/s-o-w/CIMbology.ai/blob/main/API/Services/QueryService.cs" target="_blank">
                            API/Services/QueryService.cs
                        </a>
                    </p>
                    <p>
                        The core service that orchestrates queries across both the Knowledge Graph 
                        (SPARQL) and Vector Database (RAG), then synthesizes results using Semantic Kernel.
                    </p>
                    <details>
                        <summary>View Code Snippet</summary>
                        <pre><code class="language-csharp">
                        public async Task&lt;QueryResponse&gt; ExecuteGraphRAGQueryAsync(string userQuery)
                        {
                            // 1. Query Knowledge Graph for structured data
                            var graphResults = await _sparqlService.ExecuteQueryAsync(userQuery);
                            
                            // 2. Query Vector DB for relevant document chunks
                            var vectorResults = await _vectorService.SearchAsync(userQuery, topK: 5);
                            
                            // 3. Combine contexts and generate response via LLM
                            var context = CombineContexts(graphResults, vectorResults);
                            var response = await _semanticKernel.InvokeAsync(userQuery, context);
                            
                            return new QueryResponse
                            {
                                Answer = response.Result,
                                GraphCitations = graphResults.Sources,
                                DocumentCitations = vectorResults.Sources
                            };
                        }</code></pre>
                    </details>
                </div>
                
                <div class="code-card">
                    <h4>Vector Store Service (Advanced RAG)</h4>
                    <p class="file-link">
                        <a href="https://github.com/s-o-w/CIMbology.ai/blob/main/API/Services/VectorStoreService.cs" target="_blank">
                            API/Services/VectorStoreService.cs
                        </a>
                    </p>
                    <p>
                        Manages vector embeddings and implements advanced chunking strategies 
                        (layout-aware, table extraction, multimodal processing).
                    </p>
                </div>
                
                <div class="code-card">
                    <h4>Data Model (EF Core)</h4>
                    <p class="file-link">
                        <a href="https://github.com/s-o-w/CIMbology.ai/blob/main/API/Data/CimbologyDbContext.cs" target="_blank">
                            API/Data/CimbologyDbContext.cs
                        </a>
                    </p>
                    <p>
                        The Entity Framework Core data model for chat sessions, message history, 
                        and user/organization persistence.
                    </p>
                </div>
            </div>
            
            <div class="testing-evidence">
                <h3>Testing & Validation</h3>
                <p>
                    The PE exam validation testing is fully documented and reproducible:
                </p>
                <ul>
                    <li>
                        <a href="pe_exam_analysis.html" target="_blank">
                            Interactive Results Explorer
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </section>
    
    <!-- Section 7: What I Learned -->
    <section id="lessons-learned" class="lessons-learned">
        <div class="container">
            <h2>What I Learned</h2>
            
            <div class="lesson-card">
                <h3>1. The Limits of AI: Why Knowledge Graphs Are Essential</h3>
                <p>
                    My biggest learning: LLMs are incredibly powerful pattern matchers, but they 
                    don't "understand" in the way humans do. When I tested naive RAG and saw a 
                    24% accuracy drop, it crystallized the problem: throwing vectors at an LLM 
                    without structure is like giving a student a library card but no dewey decimal 
                    system.
                </p>
                <p>
                    Knowledge Graphs provide the structured reasoning layer that makes AI trustworthy. 
                    They enforce relationships, validate data against schemas (SHACL), and enable 
                    transparent citation of sources.
                </p>
            </div>
            
            <div class="lesson-card">
                <h3>2. Containerization at Scale: Docker Orchestration Lessons</h3>
                <p>
                    Managing four containerized services (Qdrant, GraphDB, API, Web) taught me the 
                    importance of health checks, service dependencies, and volume management. 
                </p>
                <p>
                    <strong>Key lesson:</strong> Infrastructure as Code only works if it's reproducible. 
                    Every developer should be able to run <code>docker compose up</code> and have a 
                    working environment in under 2 minutes.
                </p>
            </div>
            
            <div class="lesson-card">
                <h3>3. The Importance of Testing: How I Validated Accuracy</h3>
                <p>
                    Using a real PE exam as a test set was crucial. It forced me to confront real-world 
                    questions with objectively correct answers. This is vastly different from "testing" 
                    an AI with subjective questions where any plausible answer feels acceptable.
                </p>
                <p>
                    <strong>Key lesson:</strong> If you can't measure it, you can't improve it. The 
                    66-question test set became my north star and every architectural change was validated 
                    against it.
                </p>
            </div>
            
            <div class="lesson-card">
                <h3>4. Multimodal Matters: Tables and Images Are Critical</h3>
                <p>
                    Engineering documents are rich with tables, diagrams, and figures. My early RAG 
                    attempts ignored these, treating them as "just more text." When I added table 
                    extraction and multimodal image descriptions, accuracy jumped significantly.
                </p>
                <p>
                    <strong>Key lesson:</strong> Engineering knowledge isn't just prose. Ignoring 
                    structured data (tables) and visual data (diagrams) means ignoring the most 
                    information-dense parts of a document.
                </p>
            </div>
        </div>
    </section>
    
    <!-- Section 8: Call to Action -->
    <section id="cta" class="case-study-cta">
        <div class="container">
            <h2>Interested in This Approach?</h2>
            <p>
                I'm seeking opportunities to apply this expertise in a technical leadership role 
                within the electrical utility industry. If you're facing similar knowledge management 
                challenges, let's talk.
            </p>
            <div class="cta-buttons">
                <a href="index.html#contact" class="btn-primary">Contact Me</a>
                <a href="resume.pdf" class="btn-secondary" download>Download My Resume</a>
                <a href="https://github.com/s-o-w/CIMbology.ai" class="btn-secondary" target="_blank">View on GitHub</a>
            </div>
        </div>
    </section>
    </div>
    
    <footer>
        <p>&copy; <span id="year"></span> Shawn Weekly. All rights reserved.</p>
    </footer>
    
    <script>
        // Set the current year in the footer
        document.getElementById('year').textContent = new Date().getFullYear();
        // Mobile menu toggle functionality
        const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
        const mainNav = document.querySelector('.main-nav');

        if (mobileMenuToggle && mainNav) {
            mobileMenuToggle.addEventListener('click', function (e) {
                e.stopPropagation();
                mobileMenuToggle.classList.toggle('active');
                mainNav.classList.toggle('active');
            });

            const navLinks = document.querySelectorAll('.main-nav a');
            navLinks.forEach(link => {
                link.addEventListener('click', function () {
                    mobileMenuToggle.classList.remove('active');
                    mainNav.classList.remove('active');
                });
            });

            document.addEventListener('click', function (e) {
                if (!mainNav.contains(e.target) && !mobileMenuToggle.contains(e.target)) {
                    mobileMenuToggle.classList.remove('active');
                    mainNav.classList.remove('active');
                }
            });
        }

        // Quick navigation toggle functionality
        const quickNavToggle = document.querySelector('.quick-nav-toggle');
        const quickNavItems = document.querySelector('.quick-nav-items');

        if (quickNavToggle && quickNavItems) {
            quickNavToggle.addEventListener('click', function (e) {
                e.stopPropagation();
                quickNavToggle.classList.toggle('active');
                quickNavItems.classList.toggle('active');
            });

            // Handle smooth scrolling for quick nav links
            const quickNavLinks = document.querySelectorAll('.quick-nav-btn');
            quickNavLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();

                    // Close the menu
                    quickNavToggle.classList.remove('active');
                    quickNavItems.classList.remove('active');

                    // Get the target section
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);

                    if (targetSection) {
                        // Get header height to offset scroll
                        const header = document.querySelector('header');
                        const headerHeight = header ? header.offsetHeight : 0;

                        // Calculate scroll position
                        const targetPosition = targetSection.offsetTop - headerHeight - 20;

                        // Smooth scroll
                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });
        }
    </script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</body>
</html>
